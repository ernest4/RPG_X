// TODO: my own ecs implementation. Optimized for javascript in modern JS
// Based around Ash, though (hopefully) simpler cleaner more modern JS code, taking advantage of
// modern browser features like storing lists in arrays (that get packed in memory) rather than
// linked lists that suffer fromm cache misses.
//
// NOTE: If the array contains only objects, or a mixture of numbers and objects, it’ll
// backed by an array of pointers.
// If an array is (very) sparse, it’ll no longer be backed by an array in memory. Instead, it
// will be backed by a dictionary/hashtable, and it’ll take longer to both access elements and
// iterate through the array.
//
// NOTE: no need for for loops, modern helper methods like forEach and map / filter are optimized.
// Just make sure to use a cached Function to do logic.
//
// NOTE: if using sparse arrays, make sure to use array buffers to force localization of data,
// as regular arrays get downgraded to dictionaries by V8 once they becomes sparse. Otherwise make
// sure to fill regular arrays with 0s or something to not appear 'sparse'

// TODO: jest tests !!!!
export const ECS = {};

// wip...

// Entities (simple ids, generated by engine)
// Components (arrays of components, each storing entity id and also using sparse set for fast lookup) https://programmingpraxis.com/2012/03/09/sparse-sets/
// Systems (queries for engine to return all entities having certain components) (can start with
// basic naive query, later can first choose the smallest component array and only search for
// entities stemming from those).

// needs to store an iterate over the update function references for systems
// needs to be trigger by external ticker

// NOTE: more custom type examples
// type Foot = number;
// type Pound = number;

// type Patient = {
//   name: string;
//   height: Foot;
//   weight: Pound;
// };

// TODO: need a finiteStateMachine as well. https://www.richardlord.net/blog/ecs/finite-state-machines-with-ash.html
class EntityStateMachine {
  // TODO: wip

  createState = (name: string) => {
    // TODO: ...
  };

  // TODO: this will probably live on some 'State' class as part of FSM stuff, instead of EntityStateMachine
  add = (componentName: Symbol) => {
    // TODO: add component to particular state (needs to be called on state)
  };

  // TODO: this will probably live on some 'State' class as part of FSM stuff, instead of EntityStateMachine
  withInstance = (component: Component) => {
    // TODO: add component instance to particular state (needs to be called on state)
  };
}

type DeltaTime = number;
type EntityId = number;
type QuerySet = Component[];
class Engine {
  _deltaTime: DeltaTime;
  updating: boolean;
  updateComplete: any; // TODO: better type?
  systemUpdateFunctions: ((engine: Engine, deltaTime: DeltaTime) => void)[];
  componentLists: { [key: string]: ComponentList };
  // oldEntityIdsPool: EntityId[];
  entityIdPool: EntityIdPool;

  constructor() {
    // TODO: ...
    this.systemUpdateFunctions = [];
    this._deltaTime = 0;
    this.updating = false;
    this.componentLists = {};
    // this.updateComplete = new signals.Signal(); // TODO: signals?? https://github.com/millermedeiros/js-signals
  }

  addSystem = (system: System, priority?: number) => {
    // TODO: priority integer sorting
    // simple priority based on insertion order for now...
    this.systemUpdateFunctions.push(system.update);
  };

  // getSystem

  // removeSystem

  // removeAllSystems

  addComponent = (component: Component) => {
    // NOTE: indexing using component class name
    const componentClassName = component.constructor.name;
    let componentList = this.componentLists[componentClassName];

    if (!componentList) {
      componentList = new ComponentList();
      this.componentLists[componentClassName] = componentList;
    }

    componentList.add(component);
  };

  removeComponent = (component: Component) => {
    // NOTE: indexing using component class name
    const componentClassName = component.constructor.name;
    const componentList = this.componentLists[componentClassName];
    if (!componentList) return;

    const oldEntityId = componentList.remove(component);
    // this.oldEntityIdsPool.push(oldEntityId);
    this.entityIdPool.push(oldEntityId);
  };

  generateEntityId = () => this.entityIdPool.pop();

  // TODO: ... probably involves purging components too
  removeEntity = () => {};

  // TODO: ... probably involves purging components too
  removeAllEntities = () => {};

  update = (deltaTime: DeltaTime) => {
    this.deltaTime = deltaTime;
    // TODO: cycle through the systems, in priority
    this.updating = true;
    this.systemUpdateFunctions.forEach(this.callSystemUpdateFunction);
    this.updating = false;
    // this.updateComplete.dispatch(); // TODO: signals??
  };

  // TODO: fix the typescript...
  *getQuerySetIteratorFor<T extends Component>(...componentClasses: T[]) {
    // TODO: ...
    // Query function will take shortest componentlist and loop throught the dense list of it.
    // For each denselist component with valid entityid, will check that components entityid against the rest of desired component lists and get those components (if present).
    // If no early bailouts (so all query conditions met) yield the queryset.
    // Query should be streamed via the query set, letting you operate on each component, instead of constructing an array of all results (dont waste time creating intermediary array...)

    // NOTE: finding shortest component list
    let shortestComponentListIndex = 0;

    let shortestComponentList = this.componentLists[
      componentClasses[shortestComponentListIndex].constructor.name
    ];
    componentClasses.forEach((componentClass, index) => {
      const nextShortestComponentList = this.componentLists[componentClass.constructor.name];

      if (nextShortestComponentList.size < shortestComponentList.size) {
        shortestComponentList = nextShortestComponentList;
        shortestComponentListIndex = index;
      }
    });

    // NOTE: cycling through the shortest component list
    // const componentsIterator = shortestComponentList.denseListStream();
    const componentsIterator = shortestComponentList.denseListStreamClean();

    for (const component of componentsIterator) {
      // TODO: if the entity of this component, has all the other componentClasses, yield it and it's components
      // otherwise, continue
      // componentClasses.forEach((componentClass, index) => {

      // });

      const entityId = component.entityId;

      // TODO: optimize by caching querySet array ??
      // const querySet: (number | Component)[] = [entityId]; // NOTE: setting first value as number will hint to V8 it's array of numbers...
      const querySet: QuerySet = []; // NOTE: setting first value as number will hint to V8 it's array of numbers...

      // TODO: cache componentClasses.length !!!
      const componentClassesLength = componentClasses.length;
      for (let i = 0; i < componentClassesLength; i++) {
        if (i === shortestComponentListIndex) continue; // NOTE: skip checking the shortest list !

        const componentClassName = componentClasses[i].constructor.name;
        const anotherComponent = this.componentLists[componentClassName].get(entityId);

        // ...
        if (anotherComponent) querySet.push(anotherComponent);
        else break; // NOTE: soon as we discover a missing component, abandon further pointless search for that entityId !

        // NOTE: yield querySet if all components found for entityId
        if (i + 1 === componentClassesLength) yield querySet;
      }
    }
  }

  get deltaTime() {
    return this._deltaTime;
  }

  set deltaTime(deltaTime: DeltaTime) {
    this._deltaTime = deltaTime;
  }

  // private

  callSystemUpdateFunction(systemUpdateFunction: (engine: Engine, deltaTime: DeltaTime) => void) {
    systemUpdateFunction(this, this.deltaTime);
  }
}

class EntityIdPool {
  // TODO: ...
  // first check this.oldEntityIdsPool ...
  // TODO: for the pool, you dont want to pop() or shrink the array. Use an array, keep custom
  // index tracker that gets incremented with each new item.
  // When removing, return the last item and count down the item counter.
  // Don't actually delete or pop off anything. This array needs to as fast as anything else.
  // Probably need a custom class for this as well?? FreeEntityIdPool ??
  // otherwise if pool is empty ...
  // keep track of this.lastEntityId and get the next integer after
  // maybe package this and above pool into single class EntityIdPool ??

  constructor() {
    // TODO:
    this.lastEntityId = -1;
    this.oldEntityIdPool = [];
    this.oldEntityIdPoolSize = 0;
  }

  push = () => {
    // TODO: wip
  };

  pop = () => {
    // TODO: ... wip
  };
}

// custom components will extend this.
class Component {
  entityId: EntityId;

  constructor(entityId: EntityId) {
    this.entityId = entityId;
  }
}

class ComponentList {
  // TODO: based on https://programmingpraxis.com/2012/03/09/sparse-sets/
  // has dense set (primary iteration) and sparse set (fast membership lookup)
  denseList: Component[];
  denseListComponentCount: number;
  sparseList: number[];

  constructor() {
    // TODO: will want to optimize these lists to use ArrayBuffer for dense memory access where
    // possible.
    this.denseList = [];
    this.denseListComponentCount = 0;
    // TODO: Sparse lists will become hash maps in V8 optimizer. They are less efficient in speed
    // compared too arrays. So maybe use fixed size ArrayBuffer as well? Dynamically grow it yourself?
    this.sparseList = [];
  }

  add = (component: Component) => {
    // TODO: once entity (or component) is removed, there will be holes in the list. The entity will
    // be there but will have -1 for entityId. Over time you might end up with large gaps of -1...
    // Since we can't delete elements from array without downgrading it to slower data type on V8,
    // need to instead reuse those slots with new components (for new entityIds).
    // For this to work, the global engine needs to be aware of what entityIds have been released
    // out and reuse them when returning from engine.generateEntityId().

    const currentComponentEntityId = component.entityId;

    const existingComponent = this.get(currentComponentEntityId);

    if (!existingComponent?.entityId || existingComponent.entityId === -1) {
      // NOTE: plug the existing free entity component slot in dense list
      this.denseList[this.sparseList[currentComponentEntityId]] = component;
    } else {
      // NOTE: create new entity component slot
      const denseListIndex = this.denseList.push(component);
      this.sparseList[currentComponentEntityId] = denseListIndex;
    }

    this.denseListComponentCount++;
  };

  has = (entityId: EntityId): boolean => !!this.get(entityId);

  get = (entityId: EntityId): Component | null => {
    const denseListIndex = this.sparseList[entityId];

    if (this.denseListComponentCount < denseListIndex) return null;
    if (this.denseList[denseListIndex].entityId !== entityId) return null;

    return this.denseList[denseListIndex];
  };

  remove = (component: Component): EntityId | undefined => {
    const denseListIndex = this.sparseList[component.entityId];

    // const currentEntityId = ...
    if (this.denseListComponentCount < denseListIndex) return;
    // if (this.denseList[denseListIndex].entityId !== component.entityId) return;
    if (this.denseList[denseListIndex] !== component) return; // NOTE: entity object ref should work as well...

    const oldEntityId = component.entityId;
    // this.denseList[denseListIndex].entityId = -1; // NOTE: -1 designates unused / invalid entityId
    component.entityId = -1; // NOTE: -1 designates unused / invalid entityId // NOTE: entity object ref should work as well...

    return oldEntityId;
  };

  get size() {
    return this.denseListComponentCount;
  }

  *denseListStream() {
    for (let i = 0; i < this.denseListComponentCount; i++) {
      yield this.denseList[i];
    }
  }

  *denseListStreamClean() {
    for (let i = 0; i < this.denseListComponentCount; i++) {
      const component = this.denseList[i];

      if (!component?.entityId || component.entityId === -1) continue;

      yield component;
    }
  }
}

// TODO: look at optimizing components by using ArrayBuffers where possible to store basic data
// close together in memory and maybe even in the component array...

class System {
  deltaTime: DeltaTime;
  // engine: Engine;

  // constructor(engine: Engine) {
  //   // TODO: ...
  //   this.engine = engine;
  // }

  constructor() {
    // TODO: ...
    this.deltaTime = 0;
  }

  // update = (deltaTime: DeltaTime) => {
  //   throw new Error("unimplemented");
  // };

  update(engine: Engine, deltaTime: DeltaTime) {
    throw new Error("unimplemented");
  }
}

// e.g. desired usage example (sketch) =============================================================

// interface PositionArguments {
//   entityId: EntityId;
//   x: number;
//   y: number;
//   rotation: number;
// }
class Position extends Component {
  _values: number[];
  // TODO: ...

  // nice interface example, but wanna keep things fast...
  // constructor({ entityId, x, y, rotation }: PositionArguments) {
  //   super(entityId);
  //   this._values = [x, y, rotation];
  // }

  constructor(entityId: EntityId, x: number, y: number, rotation: number) {
    super(entityId);
    this._values = [x, y, rotation];
  }

  // TODO: dynamically create these???
  get x() {
    return this._values[0];
  }

  set x(value: number) {
    this._values[0] = value;
  }

  get y() {
    return this._values[1];
  }

  set y(value: number) {
    this._values[1] = value;
  }

  get rotation() {
    return this._values[2];
  }

  set rotation(value: number) {
    this._values[2] = value;
  }
}

class Velocity extends Component {
  _values: number[];
  // TODO: ...
  constructor(entityId: EntityId, x: number, y: number, angular: number) {
    super(entityId);
    this._values = [x, y, angular];
  }

  // TODO: dynamically create these???
  get x() {
    return this._values[0];
  }

  set x(value: number) {
    this._values[0] = value;
  }

  get y() {
    return this._values[1];
  }

  set y(value: number) {
    this._values[1] = value;
  }

  get angular() {
    return this._values[2];
  }

  set angular(value: number) {
    this._values[2] = value;
  }
}

// TODO: remove the class wrapper?? maybe like in ECSY, no need for standalone class for system...
// just a function...
class MovementSystem extends System {
  update(engine: Engine, deltaTime: DeltaTime) {
    this.deltaTime = deltaTime;

    // TODO: stream the entities one by one instead of creating new node lists...
    // const nodes = engine.queryForEntitiesWith(Position, Velocity);
    // nodes.forEach(this.updateNode); // NOTE: wanna cache functions to prevent creating them from scratch

    const querySetIterator = engine.getQuerySetIteratorFor(Position, Velocity);
    for (const querySet of querySetIterator) this.updateEntity(querySet);
  }

  updateEntity = (querySet: QuerySet) => {
    const [position, velocity] = querySet;

    position.x = velocity.x * this.deltaTime;
    position.y = velocity.y * this.deltaTime;
    position.rotation = velocity.angularVelocity * this.deltaTime;
  };
}

const main = () => {
  const engine = new Engine();

  engine.addSystem(new MovementSystem());
  // other systems, order of addition matters!!

  for (let i = 0; i < 10; i++) {
    const entityId = engine.generateEntityId();

    engine.addComponent(new Position(entityId, i * i, i + i, 0));
    engine.addComponent(new Velocity(entityId, i, i, i));
    // engine.addComponent(Velocity, [entity, i * 1, i * 1]);
  }

  // some third party update function, babylon.js or phaser3 etc
  // update = deltaTime => {
  //   engine.update(deltaTime);
  // };
};
