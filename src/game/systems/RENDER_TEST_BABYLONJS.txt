var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    var spriteWidth = 64;
    var spriteHeight = 64;
    let spriteUOffset;
    var tex = new BABYLON.Texture("textures/player.png", scene)
    tex.onLoadObservable.add(() => {
        console.log(tex.getBaseSize())
        let baseSize = tex.getBaseSize()
        let cellWidth = 1 / (baseSize.width / spriteWidth);
        tex.uScale = cellWidth;
        console.log(tex.uScale);
        tex.vScale = 0.33;
        // spriteUOffset = baseSize.width / spriteWidth
        spriteUOffset = cellWidth;
    });

    var tex2 = new BABYLON.Texture("textures/player.png", scene)
    tex2.onLoadObservable.add(() => {
        console.log(tex.getBaseSize())
        let baseSize = tex.getBaseSize()
        let cellWidth = 1 / (baseSize.width / spriteWidth);
        tex.uScale = cellWidth;
        console.log(tex.uScale);
        tex.vScale = 0.33;
        // spriteUOffset = baseSize.width / spriteWidth
        spriteUOffset = cellWidth;
    });

    // var pmat = new BABYLON.StandardMaterial("pmat", scene);
    const pmat = new BABYLON.CustomMaterial("testy_mat", scene);
    pmat.AddAttribute("uvc");
    pmat.Vertex_Definitions(`
        attribute vec2 uvc;
    `);
    pmat.Vertex_Before_PositionUpdated(`
        uvUpdated += uvc;
    `);
    pmat.diffuseTexture = tex;
    // pmat.diffuseTexture.uScale = .05;
    // pmat.diffuseTexture.vScale = .33;
    // pmat.diffuseTexture.uOffset = .9525;
    pmat.diffuseTexture.vOffset = .33;
    pmat.diffuseTexture.hasAlpha = true;
    // pmat.transparencyMode = BABYLON.Material.MATERIAL_ALPHATESTANDBLEND;
    pmat.useAlphaFromDiffuseTexture = true;
    // pmat.diffuseColor = new BABYLON.Color3(0.8,0.8,1);

    const pmat2 = new BABYLON.CustomMaterial("testy_mat2", scene);
    pmat2.AddAttribute("uvc");
    pmat2.Vertex_Definitions(`
        attribute vec2 uvc;
    `);
    pmat2.Vertex_Before_PositionUpdated(`
        uvUpdated += uvc;
    `);
    pmat2.diffuseTexture = tex2;
    pmat2.diffuseTexture.vOffset = .33;
    pmat2.diffuseTexture.hasAlpha = true;
    pmat2.useAlphaFromDiffuseTexture = true;





    var plane2 = BABYLON.Mesh.CreatePlane("plane", 1, scene, true);
    plane2.scaling.y = 0.5;
	plane2.material = pmat2;
    plane2.position.y = 0.5;
    plane2.position.z = -3; // separate mesh draw order is determined by Z position, negative is closer to camera
    // plane2.renderingGroupId = 2;

    // Create camera and light
    // var bg_light = new BABYLON.HemisphericLight("Point", new BABYLON.Vector3(0, 1, 0), scene);
	// bg_light.groundColor = BABYLON.Color3.Gray();
    var light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-100, -100, 100), scene);
    // light.position.y = 10;
    // var camera = new BABYLON.ArcRotateCamera("Camera", 0, 1.2, 3, new BABYLON.Vector3(0, 0, 0), scene);
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0,0,-5), scene);
    camera.upperBetaLimit = Math.PI / 2.2; // NOTE: 45 to 0 deg (ground level)
    camera.lowerBetaLimit = BABYLON.Tools.ToRadians(45);
    // NOTE: confine horizontal bounds of movement (no movement)
    camera.upperAlphaLimit = -3.14 / 2;
    camera.lowerAlphaLimit = -3.14 / 2;
    camera.attachControl(canvas, true);

    // ORTHO camera test
    camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
    
    camera.orthoTop = 1;
    camera.orthoBottom = -1;
    camera.orthoLeft = -1;
    camera.orthoRight = 1;

	// Create a builtin shape
	// var box = BABYLON.Mesh.CreateBox("mesh", 1, scene);
	// box.showBoundingBox = true;

	// Define a material
	var material = new BABYLON.StandardMaterial("std", scene);
	material.diffuseColor = new BABYLON.Color3(0.5, 0, 0.5);

	// // Apply the material
	// box.material = material;
	// box.setEnabled(true);


    // var plane = BABYLON.Mesh.CreatePlane("plane", 1, scene);
	var plane = BABYLON.Mesh.CreatePlane("plane", 1, scene, true);
    var positions = plane.getVerticesData(BABYLON.VertexBuffer.PositionKind);
	
    console.log(positions)
	var numberOfVertices = positions.length/3;	
    console.log(numberOfVertices)
	// for(var i = 0; i<numberOfVertices; i++) {
	// 	positions[i*3] *= 1.5;
	// 	positions[i*3+1] *= 3
	// 	positions[i*3+2] *= 2.5;
	// }

    // skew in X
    positions[2*3] = -0.5;
    positions[3*3] = -1.5;

    plane.scaling.y = 0.5;
	
	plane.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

	plane.material = pmat;
    plane.position.y = 0.5;
    // NOTE: BILLBOARD MODE IMPROVES PERF!!! but can we use it???
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    // plane.rotation.x = 3.14 / 2;
    // plane.rotation.y = -1;
    plane.registerInstancedBuffer("color", 4);
    plane.registerInstancedBuffer("uvc", 2);

     var sg = new BABYLON.ShadowGenerator(1024, light);
     sg.addShadowCaster(plane);
     sg.transparencyShadow = true;

     const ground = BABYLON.Mesh.CreateGround("ground", 10, 10);
     ground.receiveShadows = true;

     plane.instancedBuffers.color = new BABYLON.Color4(1, 0, 0, 1);
     plane.instancedBuffers.uvc = new BABYLON.Vector2(0, 0);
     plane.position.z = 0;
    //  plane.renderOutline = true;
    //  plane.outlineColor = new BABYLON.Color3(0, 1, 0);
    //  plane.outlineWidth = 0.1;
    plane.renderingGroupId = 0;

    //  shadowGenerator.getShadowMap().renderList.push(newMeshes[0]);
            var range = 5;
            // var count = 1300; // with billboard, near 2.6 times perf boost !!!
            var count = 10;
            // var count = 300; // cloned meshes, can only handle 300, even with billboard.
            // var count = 500; // can handle lot less now... (without billboard)
            for (var index = 0; index < count; index++) {
                var newInstance = plane.createInstance("i" + index); // instance test. can render 1300 with billboard

                // var newInstance = plane.clone("i" + index); // clonse test.
                // // newInstance.material = pmat;
                // newInstance.registerInstancedBuffer("color", 4);
                // newInstance.registerInstancedBuffer("uvc", 2);
                // newInstance.instancedBuffers.color = new BABYLON.Color4(1, 1, 1, 1);
                // newInstance.instancedBuffers.uvc = new BABYLON.Vector2(0, 0);
                // newInstance.renderingGroupId = 0;
                // newInstance.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                var x = 1 - (Math.random() / 4);
                var z = 0;

                // var y = ground.getHeightAtCoordinates(x, z); // Getting height from ground object
                var y = 0.5;

                newInstance.position = new BABYLON.Vector3(x, y, z);

                // NOTE: nothing will help too enforce order for instances....
                if(index === 3){
                    newInstance.instancedBuffers.color = new BABYLON.Color4(0, 1, 1, 1);
                    // newInstance.position.z = 2;
                    newInstance.renderingGroupId = 0;
                    newInstance.position.z = 8;
                } else {
                    newInstance.instancedBuffers.color = new BABYLON.Color4(1, 1, 1, 1);
                    newInstance.renderingGroupId = 0;
                    }
                // trying to offset each texture per instance as test, WORKS! simple vector value offset...
                newInstance.instancedBuffers.uvc = new BABYLON.Vector2(5, 0);
                // diffuseTextures.push(newInstance.diffuseTexture)
                // newInstance.rotate(BABYLON.Axis.Y, Math.random() * Math.PI * 2, BABYLON.Space.WORLD);

                // var scale = 0.5 + Math.random() * 2;
                // newInstance.scaling.addInPlace(new BABYLON.Vector3(scale, scale, scale));

                // SHADOW TEST
                // sg.getShadowMap().renderList.push(newInstance);
            }

            var t=5;
            scene.beforeRender = function() {
                if (t==0) {	
                    pmat.diffuseTexture.uOffset -= spriteUOffset;
                    t=5;
                }
                else { t-- }
            };


 
    return scene;
}
