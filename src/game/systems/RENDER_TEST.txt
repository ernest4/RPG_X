var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    // Create camera and light
    // var bg_light = new BABYLON.HemisphericLight("Point", new BABYLON.Vector3(0, 1, 0), scene);
	// bg_light.groundColor = BABYLON.Color3.Gray();
    var light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-100, -100, 100), scene);
    // light.position.y = 10;
    var camera = new BABYLON.ArcRotateCamera("Camera", 0, 1.2, 3, new BABYLON.Vector3(0, 0, 0), scene);
    camera.upperBetaLimit = Math.PI / 2.2; // NOTE: 45 to 0 deg (ground level)
    camera.lowerBetaLimit = BABYLON.Tools.ToRadians(45);
    // NOTE: confine horizontal bounds of movement (no movement)
    camera.upperAlphaLimit = -3.14 / 2;
    camera.lowerAlphaLimit = -3.14 / 2;
    camera.attachControl(canvas, true);

	// Create a builtin shape
	// var box = BABYLON.Mesh.CreateBox("mesh", 1, scene);
	// box.showBoundingBox = true;

	// Define a material
	var material = new BABYLON.StandardMaterial("std", scene);
	material.diffuseColor = new BABYLON.Color3(0.5, 0, 0.5);

	// // Apply the material
	// box.material = material;
	// box.setEnabled(true);


    // var plane = BABYLON.Mesh.CreatePlane("plane", 1, scene);
	var plane = BABYLON.Mesh.CreatePlane("plane", 1, scene, true);
    var positions = plane.getVerticesData(BABYLON.VertexBuffer.PositionKind);
	
    console.log(positions)
	var numberOfVertices = positions.length/3;	
    console.log(numberOfVertices)
	// for(var i = 0; i<numberOfVertices; i++) {
	// 	positions[i*3] *= 1.5;
	// 	positions[i*3+1] *= 3
	// 	positions[i*3+2] *= 2.5;
	// }

    // skew in X
    positions[2*3] = -0.5;
    positions[3*3] = -1.5;

    plane.scaling.y = 0.5;
	
	plane.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);



    var pmat = new BABYLON.StandardMaterial("pmat", scene);
    var spriteWidth = 64;
    var spriteHeight = 64;
    let spriteUOffset;
    var tex = new BABYLON.Texture("textures/player.png", scene)
    tex.onLoadObservable.add(() => {
        console.log(tex.getBaseSize())
        let baseSize = tex.getBaseSize()
        let cellWidth = 1 / (baseSize.width / spriteWidth);
        tex.uScale = cellWidth;
        console.log(tex.uScale);
        tex.vScale = 0.33;
        // spriteUOffset = baseSize.width / spriteWidth
        spriteUOffset = cellWidth;
    });
    pmat.diffuseTexture = tex;
    // pmat.diffuseTexture.uScale = .05;
    // pmat.diffuseTexture.vScale = .33;
    // pmat.diffuseTexture.uOffset = .9525;
    pmat.diffuseTexture.vOffset = .33;
    pmat.diffuseTexture.hasAlpha = true;
    // pmat.transparencyMode = BABYLON.Material.MATERIAL_ALPHATESTANDBLEND;
    pmat.useAlphaFromDiffuseTexture = true;
    // pmat.diffuseColor = new BABYLON.Color3(0.8,0.8,1);

	plane.material = pmat;
    plane.position.y = 0.5;
    // plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_X;
    // plane.rotation.x = 3.14 / 2;
    // plane.rotation.y = -1;

	// plane.parent = box;
 	plane.position.z = -.51;
 	var t=5;
 	scene.beforeRender = function() {
		if (t==0) {	
			pmat.diffuseTexture.uOffset -= spriteUOffset;
			t=5;
		}
		else { t-- }
	 };

     var sg = new BABYLON.ShadowGenerator(1024, light);
     sg.addShadowCaster(plane);
     sg.transparencyShadow = true;

     const ground = BABYLON.Mesh.CreateGround("ground", 10, 10);
     ground.receiveShadows = true;

    //  shadowGenerator.getShadowMap().renderList.push(newMeshes[0]);
            var range = 10;
            var count = 5;
            for (var index = 0; index < count; index++) {
                var newInstance = plane.createInstance("i" + index);
                var x = range / 2 - Math.random() * range;
                var z = range / 2 - Math.random() * range;

                // var y = ground.getHeightAtCoordinates(x, z); // Getting height from ground object
                var y = 0.5;

                newInstance.position = new BABYLON.Vector3(x, y, z);

                // newInstance.rotate(BABYLON.Axis.Y, Math.random() * Math.PI * 2, BABYLON.Space.WORLD);

                // var scale = 0.5 + Math.random() * 2;
                // newInstance.scaling.addInPlace(new BABYLON.Vector3(scale, scale, scale));

                sg.getShadowMap().renderList.push(newInstance);
            }
 
    return scene;
}
